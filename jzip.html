<html>
<head>
<script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
<script src="jzip.js"></script>
<style>
#inputline {
  position: relative;
}
#inputline>.prompt {
  position: absolute;
  top: 0; left: 0;
}
#inputline>input {
  border: none;
  width: 100%;
  padding: 0 0 0 1.5em;
  margin: 0;
  background-color: #f8f8f8;
}
#inputline>input:focus {
  background-color: #eee;
  border: none;
  outline: none;
}
div.output {
  margin-bottom: 0.2em;
  min-height: 0.5em;
  background-color: white;
}
div.error {
  margin-top: 0.7em;
  padding: 0.2em;
  min-height: 0.5em;
  background-color: pink;
  border: 1px solid red;
  color: red;
  font-weight: bold;
}
div.echo {
  margin-bottom: 0.2em;
  min-height: 0.5em;
  color: gray;
  background-color: white;
}
div.output, #inputline, #inputline>input, #statuswindow {
  font-family: serif;
  font-size: 12pt;
}
div.output.reverse {
  color: white;
  background-color: black;
}
div.output.bold {
  font-weight: bold;
}
div.output.emph {
  font-style: italic;
}
div.output.fixed {
  font-family: monospace;
  white-space: pre;
}
button.signin {
   background-color: #DD2221; color: white; font-weight: bold;
}
#statuswindow {
  display: none;
  width: 100%;
  background-color: black;
  color: white;
  font-weight: bold;
  position: fixed;
  top: 0; left: 0;
  min-height: 1em;
  padding: 0.5em 0 0.5em 0;
      -webkit-transform: translate3d(0, 0, 0);
      -moz-transform: translate3d(0, 0, 0);
      -ms-transform: translate3d(0, 0, 0); /*only in IE10*/
}
#statuswindow>span.builtin {
  float: right;
  padding-right: 1em;
  display: none;
}

#statuswindow>span.row {
  position: absolute;
  padding-left: 1em;
  left:0;
}

.dialog {
  position: fixed;
  top: 1em;
  border: 1px solid black;
  box-shadow: 3px 3px 15px rgba(0,0,0,0.3);
  padding: 0.5em;
  background-color: white;
}
.dialog>h1 {
  font-size:15pt;
  margin: 0;
}
.dialog>div>h2 {
  font-size:13pt;
  margin: 0.5em 0 0 0;
  clear: both
}
.option {
  position: relative;
  margin-left: 2em;
  min-height: 2em;
  clear: both;
}
.option>br {
  clear: both
}
.option input[type=radio] {
  position: relative;
  left: -2em;
}
.option>button {
  float: right;
}
.option.drive { display: none }
</style>
</head>
<body>

<div id="statuswindow">
<span class="builtin" id="time">Time:</span>
<span class="builtin" id="moves">Moves:</span>
<span class="builtin" id="score">Score:</span>
</div>

<div id="inputline">
  <input id="input" type="text">
  <span class="prompt"><b>&gt;</b></span>
</div>

<div class="dialog" id="savedialog">
  <h1>Save game&hellip;</h1>
  <div class="localsave">
    <h2>&hellip;on this browser</h2>
    <div class="option">
      <input type="radio" name="savetype" value="localnew" checked/>
      <input type="text" id="savelocalnewname" placeholder="New File"/>
      <br/>
      <div class="haslocal">
      <input type="radio" name="savetype" value="localold"/>
      <select id="savelocaloldname">
      <option>Loading...</option>
      </select>
      </div>
      <br/>
      <button>Save</button>
    </div>
  </div>
  <div class="filesave">
    <h2>&hellip;on this computer</h2>
    <div class="option">
      <a download="save.sav" id="downloadsave" href="">Download save file&hellip;</a>
    </div>
  </div>
  <div class="drivesave">
    <h2>&hellip;on Google Drive</h2>
    <div class="option drive">
      <input type="radio" name="savetype" value="drivenew" checked/>
      <input type="text" id="savedrivenewname" placeholder="New File"/>
      <br/>
      <div class="hasdrive">
      <input type="radio" name="savetype" value="driveold"/>
      <select id="savedriveoldname">
      <option>Loading...</option>
      </select>
      </div>
      <br/>
      <button>Save</button>
    </div>
    <div class="option auth">
      <button class="signin">Sign in with Google</button>
    </div>
  </div>
</div>

<div class="dialog" id="restoredialog">
  <h1>Restore game&hellip;</h1>
  <div class="localrestore haslocal">
    <h2>&hellip;from this browser</h2>
    <div class="option">
      <select id="restorelocaloldname">
      <option>Loading...</option>
      </select>
      <br/>
      <button>Restore</button>
    </div>
  </div>
  <div class="filerestore">
    <h2>&hellip;from this computer</h2>
    <div class="option">
      <input type="file" id="uploadfile"/>
      <br/>
      <button>Restore</button>
    </div>
  </div>
  <div class="driverestore hasdrive">
    <h2>&hellip;from Google Drive</h2>
    <div class="option drive">
      <select id="restoredriveoldname">
      <option>Loading...</option>
      </select>
      <button>Restore</button>
    </div>
    <div class="option auth">
      <button class="signin">Sign in with Google</button>
    </div>
  </div>
</div>

<script>
(function(){
  var $input = $('#input')
    , $save = $('#savedialog')
    , $dload = $('#downloadsave')
    , $restore = $('#restoredialog')
    , $statw = $('#statuswindow')
    , srows = [], s_row=1, s_col=1
    , ls = window.localStorage || null
    , lsave = {}                        // copy of localStorage savegames
    , dsave = null                      // list of google drive savegames (null if not authenticated)
    , saveGame = ''                     // current savegame
    , history = ( ls && JSON.parse(ls.getItem('jszipHistory')||'[]') ) || []
    , hindex = history.length
    , autocomplete = {}, sortedWords = []
    , automap = {}, lastDirection=null, lastRoom=null
    , hmax = 100                        // size of command history
    , moveCount = 0                     // number of commands entered
    , restoreOpts = null
    , keyCallback = null
    , lineCallback = null
    , CLIENT_ID = '961409091716-f13l7n45n8u0uvkjqc9vjjddndd40jgs.apps.googleusercontent.com'
    , SCOPES = 'https://www.googleapis.com/auth/drive';

  // hook key events up to input widget (closure for local variables)
  function setupInput() {
    var prefix=null, currentSuggestions=[], suggestionIndex=0, typedInput='', stem='';

    // select a range of characters in the input box
    function selectRange(start,end) {
      console.log('select',start,end);
      var i=$input[0], v = $input.val(), l=v.length;
      if (i.setSelectionRange) {
        i.focus();
        i.setSelectionRange(start,end);
      } else if (i.createTextRange) {
        var range = i.createTextRange();
        range.collapse(true);
        range.moveStart('character', start);
        range.select();
      }
    }
  
    function getCaretPosition() {
      if (document.selection) {
        var sel = document.selection.createRange ();
        sel.moveStart ('character', -$input.val().length);
        return sel.text.length;
      }
      return $input[0].selectionStart || 0;
    }

    $input.focus().keydown(function(e) { 
      var v = $input.val(), last;
      //console.log(e.keyCode);
      switch(e.keyCode) {
        case 9:  // Tab
          if (prefix===null) {
            // find current last word
            typedInput=v;
            last = v.lastIndexOf(' ')+1
            prefix = v.substr(last);
            stem = v.substr(0,last);
            currentSuggestions = getAutocompleteList(prefix);
            console.log(prefix,currentSuggestions);
            suggestionIndex=0;
          }

          // cycle through suggestions
          if (suggestionIndex < currentSuggestions.length) {
            var t = stem+currentSuggestions[suggestionIndex];
            $input.val(t);
            selectRange(typedInput.length,t.length);
            suggestionIndex++;
            if (suggestionIndex == currentSuggestions.length) suggestionIndex=0;
          } 
          
          e.preventDefault();
          break;
        case 38: // Cursor up
          if (hindex>0) {
            if (v!=='') { history[hindex] = v; }
            $input.val(history[--hindex]);
          }
          e.preventDefault();
          break;
        case 40: // Cursor down
          if (hindex<history.length) {
            if (v!=='') { history[hindex] = v; }
            $input.val(history[++hindex]);
          }
          e.preventDefault();
          break;
        case 13: // Enter 
          if (v!=='') {
            hindex = history.length;
            history[hindex++] = v; 
            // only keep the last hmax commands in the history
            if (hindex>hmax) {
              history=history.slice(-hmax);
              hindex=hmax;
            }
            ls.setItem('jszipHistory',JSON.stringify(history))
          }
          if (lineCallback) {
            $input.val('');
            lineCallback(v);
          } else {
            e.preventDefault();
          }
          break;
        case 32: // space
          // accept current suggestion
          if (prefix!==null) {
            prefix=null;
            $input.val(v+' ');
            e.preventDefault();
          }
          break;
        default:
          // invalidate the current autocomplete prefix
          prefix=null;
      }
      e.stopPropagation();
    });
  };

  setupInput();

  // hook key events up to document
  $(document).keydown(function(e) {
    console.log(e.keyCode);
    if (keyCallback) {
      keyCallback(e.keyCode);
    } else {
      switch(e.keyCode) {
        case 27: // ESC
          // if dialog open
          $('.dialog').fadeOut();
          step();
          break;
      }
    }
  });

  // hide input widgets
  $('#inputline').hide();
  $('#readkey').hide();

  // get saves from localStorage
  if (ls) {
    lsave = JSON.parse(ls.getItem('jszipSaves')||'{}');
  } else {
    $('.localsave').hide();
  }

  // build save/restore widgets
  $save.hide();
  $restore.hide();
  $dload.click(function(){
    $save.fadeOut();
    step();
  });
  // auto select radio buttons
  $('#savelocaloldname').focus(function(){$('#savedialog input[type=radio]').val(['localold']);});
  $('#savelocalnewname').focus(function(){$('#savedialog input[type=radio]').val(['localnew']);});
  $('#savedriveoldname').focus(function(){$('#savedialog input[type=radio]').val(['driveold']);});
  $('#savedrivenewname').focus(function(){$('#savedialog input[type=radio]').val(['drivenew']);});
  // save/restore buttons
  $('.localsave button',$save).click(saveLocal);
  $('.localrestore button',$restore).click(restoreLocal);
  $('.drivesave button',$save).click(saveDrive);
  $('.driverestore .drive button',$restore).click(restoreDrive);
  $('.filerestore button',$restore).click(function(){restoreFile($('#uploadfile')[0].files)});

  // functions to be called from the c code
  var out = window['output']={ buf:'', text: true, reverse: false, bold: false, emph: false, fixed: false }
    , argstore = window['argstore']={};
  var writeChar = window['jsWriteChar'] = function(c) {
    //console.log('jsWriteChar',c,String.fromCharCode(c));
    if (c==13 || c==10 ) {
      if (out.text) {
        var $line = $('<div class="output"></div>').text(out.buf).insertBefore($('#inputline'));
        if (out.reverse) $line.addClass('reverse');
        if (out.bold) $line.addClass('bold');
        if (out.emph) $line.addClass('emph');
        if (out.fixed || /[^\s]\s\s/.test(out.buf)) $line.addClass('fixed');
        scrollBottom();
        addToAutocomplete(out.buf);
      } else {
        srows[s_row-1].text(out.buf);
      }
      out.buf='';
    } else {
      out.buf += String.fromCharCode(c);
    }
  }
  window['jsPrintString'] = function(s) {
    var c,t='',p=s,l=[]; 
    while(c=Module.getValue(p++, 'i8')) {
      writeChar(c);
      t+=String.fromCharCode(c);
      l.push(c)
    } 
    if (l.length>0) console.log('printstring',p-s,s,p,t,l);
  }
  window['jsFlushTo'] = function(s) {
    console.log('jsFlushTo(',s,')');
    var c=$('#'+s);
    if (out.buf=='') {
      c.hide();
    } else {
      c.text(out.buf).show();
      out.buf='';
    }
  }
  window['jsBlankStatus'] = function() {
    console.log('blank_status()');
  }
  window['jsMoveCursor'] = function(row,col) {
    console.log(out.text,row,col,out.buf);
    if (!out.text) {
      s_row=row;
      s_col=col;
    }
  }
  window['jsSplitWindow'] = function(lines) {
    $('body').css('padding-top',(lines+1)+'em');
    if (lines) {
      $statw.show().css('height',lines+'em');
      $('.row',$statw).remove();
      srows=[];
      for (var i=0; i<lines; ++i) {
        srows[i] = $('<span class="row"></span>').css('top',i+'.5em').attr('id','row'+(i+1)).appendTo($statw);
      }
    } else {
      $statw.hide();
    } 
  }
  window['jsSetAttribute'] = function( normal,reverse, bold, emph, fixed ) {
    out.reverse = ~~reverse;
    out.bold    = ~~bold;
    out.emph    = ~~emph;
    out.fixed   = ~~fixed;
    console.log('jsSetAttribute',out);
  }
  window['jsRegisterLocation'] = function(id) {
    // store current room number and name
    if (id!==lastRoom) {
      // add transition to last room
      if (lastRoom!==null && (lastRoom in automap) && lastDirection!==null) {
        automap[lastRoom][lastDirection]=id;
      }
      // add new room
      if (!(id in automap)) {
        automap[id] = {'name': out.buf};
      }
      lastRoom=id;
    }
    console.log(automap);
  }


  // tasks
  function taskGetLine(e) {
    var t=e.timeout,h=null;
    
    // prepare Autocomplete word list
    prepareAutocomplete();

    // display input line
    $('#inputline').show();
    $input.focus();
    scrollBottom();
    out.buf='';
    lineCallback=function(text) { 
      var i,l=text.length;
      
      // clean up
      $('#inputline').hide();
      $input.blur();
      lineCallback=null;
      if (h) clearTimeout(h);
      
      // set the last direction to guide the automapper
      lastDirection = parseDirection(text);

      // increase moveCount
      moveCount++;

      // echo input
      $('#inputline')
        .before($('<div class="echo"></div>')
          .text('> '+text)
          .click(function(e){
            // make previous input clickable for tablets
            $input.val(text).focus(); 
          }));

      // put text into buffer
      for (i=0;i<l;++i) {
        Module.setValue(e.buffer+i,text.charCodeAt(i),'i8');
      }
      jsrGetLine(e.cbuf, e.buffer, l, 13, e.timeout, e.action_routine );
      step();
    };

    // set up a timeout
    if (t>0) {
      h = setTimeout(function(){ 
        $('#inputline').hide();
        $input.blur();
        lineCallback=null;
        jsrGetLine(e.cbuf, e.buffer, 0, -1, e.timeout, e.action_routine ); 
        step(); 
      },t*1000);
    }
  }
  function taskInputCharacter(e) {
    var t=e.timeout,h=null;

    // display readkey bar

    keyCallback = function(c) {
      //clean up
      keyCallback = null;
      /* hide readkey bar */
      if (h) clearTimeout(h);

      jsrInputCharacter(c,t);
      step();
    }
    // set up a timeout
    if (t>0) {
      h = setTimeout(function(){ 
        keyCallback = null;
        jsrInputCharacter(-1,t); 
        step(); 
      },t*1000);
    }
  }
  function taskSave() {
    fillFileSelect('#savelocaloldname');
    fillDriveSelect('#savelocaloldname');
    $save.fadeIn();
    // store savegame as string
    var raw = FS.readFile('save.sav'),i,l=raw.length;
    saveGame = ''; for (i=0;i<l;++i) saveGame+=String.fromCharCode(raw[i]);
    FS.unlink('save.sav');
    // base64 encode the save.sav tmp for download
    $dload.attr('href','data:application/octet-stream;base64,'+window.btoa(saveGame));
  }
  function taskRestore(e) {
    fillFileSelect('#restorelocaloldname');
    $restore.fadeIn();
    restoreOpts=e;
    // provide the save.sav tmp file
  }

  
  // exported functions
  var spinupJS  = Module.cwrap('spinupJS', 'number', ['string'])
    , interpret = Module.cwrap('interpret', 'number')
    , jsrGetLine = Module.cwrap('jsrGetLine', 'number', ['number','number','number','number','number','number'])
    , jsrInputCharacter = Module.cwrap('jsrInputCharacter', 'number', ['number','number'])
    , zRestore = Module.cwrap('z_restore', 'number', ['number','number','number','number']);

  // helper functions 
  function scrollBottom() {
    $('body').hide().show(0)[0].scrollTop=$('body').height()
  }
  function error(t) {
    $('<div class="error"></div>').text(t).insertBefore($('#inputline'));
  }
  function fillFileSelect(s) {
    var g,$s=$(s),n=true;
    $s.empty();
    for (g in lsave) {
      if (lsave.hasOwnProperty(g)) {
        $s.append($('<option></option>').text(g).attr('value',g));
        n=false;
      }
    }
    if (n) { $('.haslocal').hide() }
    else   { $('.haslocal').show() }
  }
  function fillDriveSelect(s) {
    if (dsave===null) { return; }

    var g,$s=$(s),n=true;
    $s.empty();
    for (g in dsave) {
      if (dsave.hasOwnProperty(g)) {
        $s.append($('<option></option>').text(dsave[g].title).attr('value',g));
        n=false;
      }
    }
    if (n) { $('.hasdrive').hide() }
    else  { $('.hasdrive').show() }
  }
  function saveLocal() {
    var name, mode = $('#savedialog input[type=radio]:checked').val();
    if (mode=='localnew') {
      name = $('#savelocalnewname').val();
    } else if (mode=='localold') {
      name = $('#savelocaloldname').val();
    } else {
      return;
    }
    // empty name
    if (name=='') return;
    // save to localstorage
    lsave[name] = btoa(saveGame);
    ls.setItem('jszipSaves',JSON.stringify(lsave));
    // get back into game
    $save.fadeOut();
    step();
  }
  function restoreLocal() {
    var e=restoreOpts, name = $('#restorelocaloldname').val();
    if (e==null) {
      throw Error('No z_restore options available!');
    }
    FS.createDataFile('/', 'save.sav', atob(lsave[name]), true, true);
    restoreOpts=null;
    $restore.fadeOut();
    zRestore(e.count,e.o0,e.o1,e.o2);
    step();
  }
  function saveDrive() {
    var id=null, name, mode = $('#savedialog input[type=radio]:checked').val(), method;
    if (mode=='drivenew') {
      name = $('#savedrivenewname').val();
      if (name=='') return;
    } else if (mode=='driveold') {
      id = $('#savedriveoldname').val();
      if (dsave===null || !(id in dsave)) return;
      name = dsave[id].title;
    } else {
      return;
    }

    // save to Google Drive
    var boundary = '-------314159265358979323846'
      , delimiter = "\r\n--" + boundary + "\r\n"
      , close_delim = "\r\n--" + boundary + "--"
      , metadate
      , base64Data = btoa(saveGame);
    
    // specify original metadata and use method 'PUT' to allow update of existing file
    if (id) {
      metadata = dsave[id];
      id='/'+id; // append /id to xhr url causes an update of an existing file
      method='PUT';
    } else {
      metadata = {
        'title': name,
        'mimeType': 'application/octet-stream'
      };
      id='';
      method='POST';
    }

    var multipartRequestBody =
          delimiter +
          'Content-Type: application/json\r\n\r\n' +
          JSON.stringify(metadata) +
          delimiter +
          'Content-Type: application/octet-stream\r\n' +
          'Content-Transfer-Encoding: base64\r\n' +
          '\r\n' +
          base64Data +
          close_delim
      , request = gapi.client.request({
          'path': '/upload/drive/v2/files'+id,
          'method': method, 'alt': 'json',
          'params': {'uploadType': 'multipart', 'alt': 'json'},
          'headers': { 'Content-Type': 'multipart/mixed; boundary="' + boundary + '"' },
          'body': multipartRequestBody
        });

    request.execute(function(e){
      // refresh the file lists
      retrieveAllFiles();
      // get back into game
      $save.fadeOut();
      step();
    });
  }
  function restoreDrive() {
    var e=restoreOpts, id = $('#restoredriveoldname').val();
    if (e==null) {
      throw Error('No z_restore options available!');
    }
    if (dsave===null || !(id in dsave)) { return; }
    downloadDriveFile(id);
  }
  function restoreFile(fl) {
    if (fl.length!=1) { return; }
    var f=fl[0];

    // instantiate a new FileReader
    var reader = new FileReader();
    reader.onload=function(e) {
      FS.createDataFile('/', 'save.sav', e.target.result, true, true);
      restoreOpts=null;
      $restore.fadeOut();
      zRestore(e.count,e.o0,e.o1,e.o2);
      FS.unlink('save.sav');
      step();
    }
    reader.readAsBinaryString(f);
  }
  window['googleAPILoaded'] = function(){
    setTimeout(checkAuth, 1);
  }
  function checkAuth() {
    gapi.auth.authorize( { 'client_id': CLIENT_ID, 'scope': SCOPES, 'immediate': true}, handleAuthResult);
  }
  function handleAuthResult(authResult) {
    if (authResult && !authResult.error) {
      // Access token has been successfully retrieved, requests can be sent to the API.
      $('.option.drive').show();
      $('.option.auth').hide();
      // fetch list of files
      gapi.client.load('drive', 'v2', function() {
        console.log("Google Drive API loaded.");
        retrieveAllFiles();
      });
    } else {
      $('.option.auth button').click(function() {
        gapi.auth.authorize( {'client_id': CLIENT_ID, 'scope': SCOPES, 'immediate': false}, handleAuthResult);
      });
    }
  }
  function retrieveAllFiles() {
    var retrievePageOfFiles = function(request, result) {
      request.execute(function(resp) {
        result = result.concat(resp.items);
        var nextPageToken = resp.nextPageToken, num, suf;
        if (nextPageToken) {
          request = gapi.client.drive.files.list({'pageToken': nextPageToken });
          retrievePageOfFiles(request, result);
        } else {
          // retrieved result, build dsave list of eligible files that are not in trash
          dsave = {};
          for (var i=0; i<result.length; ++i ) {
            if (result[i].mimeType == 'application/octet-stream' &&
                result[i].labels.trashed == false) {
              dsave[result[i].id] = result[i];
            }
          }
          fillDriveSelect('#savedriveoldname');
          fillDriveSelect('#restoredriveoldname');
        }
      });
    }
    var initialRequest = gapi.client.drive.files.list();
    retrievePageOfFiles(initialRequest, []);
  }
  function downloadDriveFile(id) {
    var accessToken = gapi.auth.getToken().access_token
      , url = dsave[id].downloadUrl
      , e=restoreOpts
      , xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.setRequestHeader('Authorization', 'Bearer ' + accessToken);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function() {
      if (xhr.status == 200) {
        FS.createDataFile('/', 'save.sav', new Uint8Array(xhr.response), true, true);
        restoreOpts=null;
        $restore.fadeOut();
        zRestore(e.count,e.o0,e.o1,e.o2);
        FS.unlink('save.sav');
      } else {
        error("Google Drive returned an error: " + xhr.statusText );
      }
      step();
    };
    xhr.onerror = function() {
      // should probably report an error first
      error("Error fetching file from Google Drive.");
      $restore.fadeOut();
      step(); 
    };
    xhr.send();
  }
  function addToAutocomplete(text) {
    // add words from text to autocomplete hash (with current moveCount)
    var words = text.split(/[\s,.!?)(]+/), i, l=words.length, word;
    for (i=0; i<l; ++i) {
      word = words[i].toLowerCase();
      if (/^[a-zA-Z-]+$/.test(word) && word.length>2) {
        autocomplete[word]=moveCount;
      }
    }
  }
  function prepareAutocomplete() {
    // expire words from more than 5 moves back
    var word;
    sortedWords=[];
    for (word in autocomplete) {
      if (autocomplete.hasOwnProperty(word)) {
        if (autocomplete[word]+5<moveCount) {
          delete autocomplete[word]; 
        } else {
          sortedWords.push(word);
        }
      }
    }

    sortedWords.sort();
    console.log(sortedWords);
  }
  function getAutocompleteList(p) {
    // get a list of all candidate words in the AC list
    if (p==='') return [];
    // do linear search (simpler)
    var l=sortedWords.length, a, b;
    // get start of slice (first candidate)
    for(a=0; a<l && p>sortedWords[a]; ++a);
    for(b=a; b<l && sortedWords[b].indexOf(p)==0; ++b); 
    return sortedWords.slice(a,b);
  }
  function parseDirection(command) {
    // try to parse user input to store the last geiven direction of movement
    var v=command.toLowerCase();
    if (/^n$|^north$|^go north$/.test(v)) return 'n';
    if (/^e$|^east$|^go east$/.test(v)) return 'e';
    if (/^s$|^south$|^go south$/.test(v)) return 's';
    if (/^w$|^west$|^go west$/.test(v)) return 'w';
    if (/^u$|^up$|^upstairs$|^go up$/.test(v)) return 'u';
    if (/^d$|^down$|^downstairs$|^go down$/.test(v)) return 'd';
    if (/^ne$|^northeast$|^go northeast$/.test(v)) return 'ne';
    if (/^nw$|^northwest$|^go northwest$/.test(v)) return 'nw';
    if (/^se$|^southeast$|^go southeast$/.test(v)) return 'se';
    if (/^sw$|^southwest$|^go southwest$/.test(v)) return 'sw';
    return null;
  }


  // Start z-machine
  spinupJS('moonmist.z3');
  //spinupJS('zork2.z3');
  //spinupJS('curses.z5');

  // call interpreter
  function step() {
    try {
      interpret();
    } catch(e) {
      console.log('Exception:',e);
      switch(e.task||'') {
        case 'getLine': 
          taskGetLine(e); 
          break;
        case 'inputCharacter': 
          taskInputCharacter(e); 
          break;
        case 'z_save':
          taskSave();
          break
        case 'z_restore':
          taskRestore(e);
          break
        default:
          error("jzip.js terminated. Reload the page to play again.");
      }
    }
  }
  step();
})();
</script>
<script src="https://apis.google.com/js/client.js?onload=googleAPILoaded"></script>
</body>
</html>
